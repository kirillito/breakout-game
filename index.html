<html>
<head></head>
<body>
	<canvas id="gameCanvas" width="800" height="600"></canvas>

	<script>
		var canvas;
		var canvasContext;

		const TOP_INFO_HEIGHT = 20

		var ballX = 50;
		var ballSpeedX = 10;
		var ballY = 50;
		var ballSpeedY = 10;

		var paddleX = 250;
		var paddleY = 590;
		const PADDLE_THICKNESS = 10;
		const PADDLE_WIDTH = 100;
    const BALL_RADIUS = 7;

		const BRICK_W = 80;
		const BRICK_H = 20;
		const BRICK_GAP = 2;
		const BRICK_COLS = 10;
		const BRICK_ROWS = 14;
		var brickGrid = new Array(BRICK_ROWS * BRICK_COLS);
		var brickCounter = 0;

		var playerScore = 0;
		const BRICK_SCORE = 10;		
		const STARTING_LIVES = 3;
    var playerLives = STARTING_LIVES;

		var showingLoseScreen = false;
		var showingWinScreen = false;

		window.onload = function() {
			canvas = document.getElementById('gameCanvas');
			canvasContext = canvas.getContext('2d');
			
			paddleY = canvas.height - 10;
			bricksReset();

			var framesPerSecond = 30;
			setInterval(function() {
				animate();
				draw();
			}, 1000/framesPerSecond);

			canvas.addEventListener('mousemove', 
				function(e) {
					var mousePos = calculateMousePos(e);
					paddleX = mousePos.x - PADDLE_WIDTH/2;
				}
			);

			canvas.addEventListener('mousedown', handleMouseClick);

			ballReset();
		}

		function calculateMousePos(e) {
			var rect = canvas.getBoundingClientRect();
			var root = document.documentElement;
			var mouseX = e.clientX - rect.left - root.scrollLeft
			var mouseY = e.clientY - rect.top - root.scrollTop

			return {
				x:mouseX,
				y:mouseY
			}
		}

		function handleMouseClick(e) {
			if(showingLoseScreen) {
				playerScore = 0;
				playerLives = STARTING_LIVES;
				showingLoseScreen = false;

				bricksReset();
				ballReset();
			}
			else if(showingWinScreen) {
				showingWinScreen = false;

				bricksReset();
				ballReset();
			}
		}

		function ballReset() {
      if (playerLives <= 0) {
				showingLoseScreen = true;
			}

			ballSpeedX = -ballSpeedX;
			ballX = canvas.width/2
			ballY = paddleY-PADDLE_THICKNESS-BALL_RADIUS*2;
      paddleX = (canvas.width-PADDLE_WIDTH)/2;
		}

		function bricksReset() {
			for (var i=3*BRICK_COLS; i<BRICK_ROWS * BRICK_COLS; i++) {
				brickGrid[i]	= 1;
				brickCounter++;
			}
		}

		function doesBrickExist(row, col) {
			var brickIndex = brickCoordToIndex(row, col);
			return (brickGrid[brickIndex] == 1);
		}

		function brickCoordToIndex(row, col) {
			return col + BRICK_COLS * row;
		}

		function breakAndBounceOffBrickAtPixelCoord(x, y) {
			var col = Math.floor(x/BRICK_W);
			var row = Math.floor(y/BRICK_H);

			// outside the brick area - don't do anything
			if (col < 0 || col >= BRICK_COLS || row < 0 || row >= BRICK_ROWS) 
				return;

			var brickIndex = brickCoordToIndex(row, col);
			// if brick is not removed
			if (brickGrid[brickIndex] == 1) {
				previousCol = Math.floor((ballX-ballSpeedX) / BRICK_W);
				previousRow = Math.floor((ballY-ballSpeedY) / BRICK_H);

				var bothTestsFailed = true;

				// ball changed columns of the brick grid
				if (previousCol != col) {
					// make sure that there is no horizontally adjacent brick from where the ball is coming
					var	adjacentBrickIndex	=	brickCoordToIndex(row, previousCol);
					if (brickGrid[adjacentBrickIndex] != 1)	{
						ballSpeedX = -ballSpeedX;
						bothTestsFailed	= false;
					}
				}

				// ball changed rows of the brick grid
				if (previousRow != row) {
					// make sure that there is no vertically adjacent brick from where the ball is coming
					var	adjacentBrickIndex	=	brickCoordToIndex(previousRow, col);
					if (brickGrid[adjacentBrickIndex] != 1)	{
						ballSpeedY = -ballSpeedY;
						bothTestsFailed	= false;
					}
				}

				// the ball hit three bricks in L-like shape - reverse movement 
				if (bothTestsFailed) {
					ballSpeedX = -ballSpeedX;
      		ballSpeedY = -ballSpeedY;
				}

				brickGrid[brickIndex] = 0;
				brickCounter--;
				playerScore += BRICK_SCORE;
				
				if (brickCounter == 0) {
					showingWinScreen = true;
				}
			}
			return;
		}

		function animate() {
			if(showingLoseScreen) {
				return;
			}

			ballX = ballX + ballSpeedX;
			ballY = ballY + ballSpeedY;

			if (ballY <=  BALL_RADIUS) {
				ballSpeedY = -ballSpeedY
			}
			if (ballY >= paddleY-PADDLE_THICKNESS-BALL_RADIUS 
					&& ballX >= paddleX && ballX <= paddleX+PADDLE_WIDTH
					&& ballSpeedY > 0) {
				ballSpeedY = -ballSpeedY

				var deltaX = ballX - (paddleX + PADDLE_WIDTH/2);
				ballSpeedX = deltaX * 0.35;
			} else if (ballY >= canvas.height) {
					playerLives--;
					if (!playerLives) {
						showingLoseScreen = true;
					}

					ballReset();
			}
			if (ballX >= canvas.width-BALL_RADIUS || ballX <= BALL_RADIUS) {
				ballSpeedX = -ballSpeedX
			}

			breakAndBounceOffBrickAtPixelCoord(ballX, ballY);
		}

		function draw() {	
			// background
			drawRectangle(0,0,canvas.width,canvas.height,'black');

			if(showingLoseScreen) {
				canvasContext.fillStyle = 'white';

				canvasContext.fillText("You're score: " + playerScore, 350, 200);

				canvasContext.fillText("click to continue", 350, 500);
				return;
			} else if(showingWinScreen) {
				canvasContext.fillStyle = 'white';

				canvasContext.fillText("You Win! You're score: " + playerScore, 350, 200);

				canvasContext.fillText("click to continue", 350, 500);
				return;
			}

			drawBricks();

			// paddle
			drawRectangle(paddleX,paddleY - PADDLE_THICKNESS,PADDLE_WIDTH,PADDLE_THICKNESS,'white');

			// ball
			drawCircle(ballX, ballY, BALL_RADIUS, 'yellow')

			canvasContext.fillStyle = 'white';
			canvasContext.fillText("Lives: " + playerLives, canvas.width - 200, 10)
			canvasContext.fillText("Score: " + playerScore, canvas.width - 100, 10)
		}

		function drawBricks()	{
			for (var i=0;	i<BRICK_ROWS;	i++) {
				for (var j=0;	j<BRICK_COLS;	j++) {
					if (doesBrickExist(i, j)) {
						var	brickX = j * BRICK_W;
						var	brickY = i * BRICK_H + TOP_INFO_HEIGHT;

						drawRectangle(brickX,	brickY, BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'blue');
					}
				}
			}
		}

		function drawRectangle(leftX, topY, width, height, drawColor) {
			canvasContext.fillStyle = drawColor;
			canvasContext.fillRect(leftX,topY,width,height);
		}

		function drawCircle(centerX, centerY, radius, color) {
			canvasContext.fillStyle = color;
			canvasContext.beginPath();
			canvasContext.arc(centerX, centerY, radius, 0, Math.PI*2, true)
			canvasContext.fill();
		}
	</script>
</body>
</html>